|       | 월                           | 화                           | 수                           | 목                           | 금                           |
| ----- | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- |
| 1주차 | [2021.07.05](#20210705day01) | [2021.07.06](#20210706day02) | [2021.07.07](#20210707day03) | [2021.07.08](#20210708day04) | [2021.07.09](#20210709day05) |
| 2주차 | [2021.07.12](#20210712day06) | [2021.07.13](#20210713day07) | [2021.07.14](#20210714day08) | [2021.07.15](#20210715day09) | [2021.07.16](#20210716day10) |
| 3주차 | [2021.07.19](#20210719day11) | [2021.07.20](#20210720day12) | [2021.07.21](#20210721day13) | [2021.07.22](#20210722day14) | [2021.07.23](#20210723day15) |
| 4주차 | [2021.07.26](#20210726day16) | [2021.07.27](#20210727day17) | [2021.07.28](#20210728day18) | [2021.07.29](#20210729day19) | [2021.07.30](#20210730day20) |
| 5주차 | [2021.08.02](#20210802day21) | [2021.08.03](#20210803day22) | [2021.08.04](#20210804day23) | [2021.08.05](#20210805day24) | [2021.08.06](#20210806day25) |
| 6주차 | [2021.08.09](#20210809day26) | [2021.08.10](#20210810day27) | [2021.08.11](#20210811day28) | [2021.08.12](#20210812day29) | [2021.08.13](#20210813day30) |
| 7주차 | 대체공휴일                   | [2021.08.17](#20210817day31) | [2021.08.18](#20210818day32) | [2021.08.19](#20210819day33) | [2021.08.20](#20210820day34) |
| 8주차 | [2021.08.23](#20210823day35) | [2021.08.24](#20210824day36) |                              |                              |                              |

# 2021.08.24[DAY36]

## 오늘한일
- 피드백 및 수정사항 반영
  * ViewPager 메모리 누수 방지 해결
  * 월뷰 Fragment 로딩 시 메인 스레드를 정지하지 않도록 변경
  * 캘린더 체크 / 해제 시 전체를 다시 그리지 않도록 변경 ( 캘린더 체크/해제 뿐만 아니라 동기화 시에도 전체를 다시 그리지 않도록 변경해보기 )
  * 대체공휴일+공휴일 날짜 색상 빨갛게 표시
  * 

- 발표자료 제작
  * 중간발표 자료에 발표 이후에 진행한 작업을 보충하여 발표자료 완성
  * 설계부분은 중간발표에서 진행을 한 관계로 앱 검증 및 데모테스트 위주로 작성
  * Dagger, Unit Test 등 새로 추가된 부분 추가
## 내일할일
- 최종발표 준비 및 시뮬레이션 & 최종발표

## 생각해 볼 점
- Recursive(반복)이벤트의 경우에는 남은 시간 내에 구현하기에는 난이도가 있어서 아직 구현을 하지 못한 상황이다. 하지만 일정 추가 시뮬레이션을 진행하다보니 해당 부분도 꼭 구현해보고 싶다는 생각이 들었고, 내일 남은시간에 구현을 끝까지 하진 못하더라도 구현할 수 있는 방법에 대해 생각해보자.

- 최종발표를 최대한 루즈해지지 않도록, 중간 발표에 진행했던 부분들은 과감하게 스킵을 하고 선택과 집중을 하여 효율적인 발표를 구성하자.

# 

# 2021.08.23[DAY35]

## 오늘한일
- [테스트 코드 작성 마무리]
  * UI테스트를 제외한 Data 영역의 Unit Test 코드를 작성 및 마무리
  * 테스트 코드를 Jacoco를 이용해 커버리지 측정을 완료함

- [코드리뷰 피드백 내용 중 수정이 가능한 부분 수정하기]
  * 시작 / 종료 날짜로 이벤트를 검색하여 날짜에 맞는 칸에 이벤트뷰를 붙여줬던 방식은 시작/ 종료 날짜에만 표시되며 시작~종료 사이에 있는 날짜에는 이벤트가 등록되지 않은 문제로
    DB쿼리를 조회할 때, 시작.종료 날짜로 조회하는 쿼리를 (시작 날짜 < 다음달1일 and 종료날짜 >= 현재달1일) 로 데이터를 조회함으로써
    정상적으로 이벤트들이 각각의 날짜에 알맞게 표시되도록 수정
  * API 데이터 호출 시 SyncToken을 활용하여 필요한 데이터만 불러올 수 있도록 하여 성능업
  * 동기화 시 월뷰를 가리지 않도록 수정
## 내일할일
- 발표자료 제작 및 남은시간을 활용하여 피드백 수정

## 생각해 볼 점
- 이슈 문제를 해결하기 위해 깊게 고민하다가 생각이 안나는 경우에, 갑자기 일상생활 중에 문뜩 떠오를 때가 있다.

- 내일 남은기간동안 틈날 때 마다 이슈문제를 한 번 생각해보면서 고칠 수 있는 부분은 최대한 고쳐보자. 

# 

# 2021.08.20[DAY34]

## 오늘한일
- [테스트 코드 작성 시작]
  * 남은 기간동안 UI . Unit Test 코드를 모두 작성하기에는 시간이 부족하다고 판단되어 UI를 제외한 Unit Test 코드만을 작성하기로 함
  * 실질적으로 테스트가 가장 필요한 부분들을 우선적으로 선별하여 해당 클래스들에 대한 테스트 코드 작성 시작
## 내일할일
- 주말을 할애하여 Unit Test 코드 작성 마무리 및 월요일에 프로젝트 코드 작성 최종 마무리

## 생각해 볼 점
- Unit/UI Test라는 개념에 대해 처음 접해본 상황이라, 시작을 하는데에 있어 다소 어려운 부분들이 있었다.

- 이번 프로젝트를 계기로, 테스트 코드에 대한 개념과 필요성 등을 공부해보고자 한다.

- 마지막 주말인 만큼, 주말을 할애해서라도 프로젝트를 완수할 수 있도록 노력해보자.

# 

# 2021.08.19[DAY33]

## 오늘한일
- [Dagger 적용 최종 마무리]
  * Unit Test를 진행할 부분을 우선순위로, Dagger 를 적용하여 코드를 리팩토링 함
  * 의존성 주입이 필요하다고 판단되는 부분들에 대한 Dagger 적용 및 코드 리팩토링 마무리

- [Unit Test에 대한 개념 학습 및 작성 시작]
  * 남은 기간동안 모든 브랜치에 대한 테스트를 진행하기에는 다소 무리가 있다고 판단
  * Unit Test를 진행할 클래스 선택 및 정리
  * 테스트 코드 작성 환경 세팅
## 내일할일
- Unit Test 코드 작성 시작

## 생각해 볼 점
- 최종 발표 기간이 조금 앞당겨짐에 따라 기존 플랜을 조율하여 프로젝트 과제를 마무리할 수 있도록 하자.

- 테스트 코드를 작성하기로 선별한 클래스들에 대해 성공적으로 테스트 코드를 작성할 수 있도록 선택과 집중을 하자.

# 

# 2021.08.18[DAY32]

## 오늘한일
- [Dagger을 이용한 의존성 주입 및 코드 리팩토링](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/Dagger%20리팩토링.md)
  * 각각의 Activity와 ViewModel, Preference, Repository등 기존에 작성한 코드들에 Dagger을 이용해 의존성을 주입하여 코드를 리팩토링
  * AndroidSupportInjection을 이용해 보일러 플레이트 코드 줄이기
  * 보일러 플레이트 코드를 줄임으로써 SubComponent와 관련된 부분 수정 및 리팩토링

- [의존성 주입과 Dagger에 대한 개념 정리]
  * [네이버 Dagger 강의 수강](https://share.navercorp.com/dagger/joinLectures/229539)

- 코드리뷰 피드백 받은 내용 중 일부분 피드백 반영 수정
  * 동기화를 하는 동안 로딩바가 월뷰를 가리고 있는 부분: 로딩바를 월뷰에서 네비게이션 드로어로 옮김으로써 월뷰 화면을 가리지 않고 동기화를 진행할 수 있도록 수정
## 내일할일
- Dagger 적용 및 코드 리팩토링 최종 마무리

- Unit Test에 대한 개념과 테스트 코드를 어떻게 작성할지에 대해 찾아보기

## 생각해 볼 점
- 의존성 주입을 진행하면서 객체 지향적인 프로그래밍에 대해 좀 더 친숙해 지며, 객체지향적인 프로그래밍에 대해 좀 더 생각해보게 되었다.
- 남은 기간동안 최대한 Test Code에 대한 개념을 습득하여 작성할 수 있도록 효율적인 방법 생각해보기 

# 

# 2021.08.17[DAY31]

## 오늘한일
- 코드리뷰 및 피드백 정리
  * 동기화를 하는 동안 로딩이 월뷰를 가리고 있는 부분에 대해 화면을 가리지 않고 동기화를 진행할 수 있도록 수정
  * 월뷰에 데이터 변화가 발생하면 변화가 발생한 부분만 다시 그릴 수 있도록 수정
  * 몇 개월에 걸쳐서 발생한 이벤트에 대해 나타낼 수 있는 방법 생각해보기
  * (현재는 8월 이벤트를 가져올 때 이벤트 시작 날짜가 8월인 이벤트를 가져오게 되는데, 3월에 시작해서 9월에 끝나는 경우에는 못가져오기 때문에 가져올 수 있는 방법 생각해보기)

- DI 이어서 구현하기
## 내일할일
- 어제 피드백 받은 부분들을 하나씩 수정해보며 최적화 진행

- DI 이어서 구현하기

## 생각해 볼 점
- 코드리뷰를 진행하면서 생각해보지 못했던 부분들에 대한 피드백을 받을 수 있었다.
- 피드백 받은 부분들이 왜 필요하고 왜 그렇게 수정해야 되는지에 대해 생각해보고 수정을 진행해보자.

# 

# 2021.08.13[DAY30]

## 오늘한일
- [중간발표 및 피드백 정리]
  * 오전에 중간발표를 위한 피피티 정리 및 발표자료 보완
  * 오후에 중간발표 진행
  * 발표 후 자료 정리 및 피드백 정리

- DI 기본 셋팅(Application Activity의 Component와 Module)
## 내일할일
- 지금까지 구현된 부분에 대한 코드 리뷰
  * 안드로이드 인턴 코드 리뷰 진행
  * 코드리뷰 피드백 정리 및 수정 시작

- DI 이어서 구현하기

## 생각해 볼 점
- DI와 테스트 코드를 어느 정도까지 진행한 후에 최적화 및 기능보완을 진행할 것인지 생각해보기

# 

# 2021.08.12[DAY29]

## 오늘한일
- [어제 발생했던 체크 선택/해제 시 월뷰 UI 오류 해결](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/캘린더%20체크:해제시%20UI%20표시%20오류%20이슈.md)
  * ViewPager2의 페이지 저장 기능과, ShareViewModel이 혼합되어 발생한 오류였음.
  * 로그를 찍어보고 디버깅을 진행하며 오류의 발생원인을 찾아봄
  * 오류를 해결하는데에 시간을 많이 소비하기도 하였고 앞으로는 이러한 오류를 범하지 않기 위해 오류를 분석하여 문서로 저장

- 이슈해결로 인해 변경된 사항들을 시퀀스 다이어그램과 설계도에 반영함
## 내일할일
- 인턴 과제 중간발표
  * 오전에 중간발표 자료 최종정리 및 연습
  * 오후 중간발표 후에 최종 발표를 위해 잘 다듬기

- 구현된 기본 기능들 잘 다듬기

## 생각해 볼 점
- 어느정도 기본기능들을 모두 구현하였기 때문에, 선택지(DI와 테스트 코드 작성 / 성능개선 및 최적화)중 어떤 것을 선택하여 남은 2주를 진행할지 이번주까지 최종 고민해보기

# 

# 2021.08.11[DAY28]

## 오늘한일
- 발표자료 추가 및 수정
  * 지난주에 정리해놓은 발표자료에 이번주 추가한 내용들을 정리하여 보완하였음
  * 중간중간 수정된 시퀀스와 퓨처들을 보완하여 정리함

- 캘린더 별 체크박스 선택/해제 중 오류 발생 및 오류 수정 (미해결)
  * 현재 월뷰(MonthFragment)에서 대한민국 공휴일이나 내 캘린더 등 체크박스 선택/해제 동작을 하면 notifyDataSetChanged 되도록 구현해놓았음.
  * 체크박스가 선택된 캘린더만 화면에 바로 나타날 수 있도록 이렇게 구현을 했는데. 각 월에 맞지 않는 이벤트가 나타나는 오류가 발생함.

- 오류 해결 과정 정리
  * 현재 오류는 8월 뷰에서 체크박스중 하나를 선택하면 갑자기 9월 이벤트가 8월 뷰에 나타남. (단, 8월의 일자들은 정상적으로 출력됨)
  * 한가지 문제 원인으로, ViewPager특성상 9월에서 8월로 넘어올때 다음 페이지인 9월 MonthFragment가 미리 create가 되고 있고 현재 상태에서 notify를 하면 8월이벤트가 아닌 9월 이벤트들이 띄워지는 것 같은 의심이 들었음. 다만 날짜(1..31)는 각 월에 맞게 잘나오는 상황.
  * 만약, 현재 뷰페이저에 8, 9, 10 MonthFragment가 Create된 상황이고. 가장 마지막으로 10월 MonthFragment가 생성되었다면. 10월 이벤트가 8, 9월에도 표시됨.
  * 예를들어, 10월중 한 이벤트가 10월 9일날 발생하였고 10월 9일의 Position은 13이라면 9월 달력에는 9월의 날짜와 상관없이 9월의 13 포지션에 이벤트가 표시되고 있음.
  * 로그를 찍어본 결과 9월 달력에는 정상적으로 9월의 이벤트와 날짜가 들어가있음.
  * notifyDataSetChanged를 하지 않으면 오류가 발생하지 않지만, 실시간으로 체크/해제 상태에 따라 이벤트를 반영할 수 없음.
  * 왜 notify만 하면 UI 오류가 나는지 좀 더 고민해보고..
  * 체크/해제 버튼을 별도의 프레그먼트에 표시할지. 아니면 오류를 계속 찾아 해결하여 수정할지 좀 더 고민을 해봐야 할 것 같다.
## 내일할일
- 오늘 발생했던 UI 관련 오류 해결하기
  * 발생 원인이 될 사항들을 하나씩 분석하여 이를 정리해보기
  * 정리한 내용들을 토대로 하나씩 테스트해보면서 원인 찾아보기
  * 해결이 안된다면 뷰페이저 로직이 잘못된 것이므로 다소 시간이 걸리더라도 천천히 뷰페이저 구성 수정하기.

## 생각해 볼 점
- 오류를 해결하는데에 있어서, 무작정 생각나는대로 테스트해보고 수정해보고 하면 같은 테스트를 반복하게 되는 것 같다.

- 어떤 부분을 테스트할지, 어떤 부분을 테스트 했는지에 대해 정리를 하여 메모를 해두고 이 메모를 토대로 테스트를 해야 같은 부분을 반복하지 않고 효율적으로 테스트를 할 수 있음을 알게되었다.

# 


# 2021.08.10[DAY27]

## 오늘한일
- 캘린더 UI 중 이벤트 관련 UI 수정
  * 여러 일자에 걸친 이벤트를 하나의 띠로 길게 표시하는 UI 로직을 짜기 시작함
  * 해당 부분을 구현하는데에 상당히 복잡함을 느꼈고, 멘토님도 해당 부분은 심화적인 기능을 다룰 때 처리하는 것이 좋다고 하셔서 일단 보류를 해두었음.

- 캘린더 별 체크박스 선택/해제 기능 구현 시작
  * 하나의 구글 계정에는 여러 캘린더가 존재할 수 있음(내 캘린더, 공휴일 캘린더, 초대받은 캘린더 등)
  * 캘린더 별로 선택/해제 하는 기능을 추가하기 위해 네비게이션 Drawer와 네비게이션 뷰에 체크박스 아이템 추가 기능을 구현함
## 내일할일
- 지난 주 정리해놓은 발표자료에 이번주 내용들을 추가하여 발표자료 수정하기
  * 이번주에 추가된 이벤트 UI 나타내기, 날짜 이동 다이얼로그 등 추가된 사항들을 잘 정리하여 발표자료에 정리하기

_ 지금까지 구현된 부분들을 테스트 해보면서 깔끔하게 정리해보기

## 생각해 볼 점
- 체크박스 선택 / 해제를 통해 월 뷰에 변화를 주려면 프레그먼트 간 상호작용이 필요할 것 같다.

- 처음에는 이 개념을 잘 모르고 있어서, 체크박스 선택 / 해제 상태를 Preference나 매개변수로 저장하려고 했지만 상당히 비효율적임을 느꼈다. 그러다가 ShareViewModel을 통해 간단하게 처리할 수 있을 것 같다고 생각되어 이 부분을 내일 어떻게 구현할지 고민해보고 직접 구현해보려고 한다.

# 

# 2021.08.09[DAY26]

## 오늘한일
- 각각의 월 프레그먼트에서 불러온 이벤트들을 달력의 각 아이템(칸)에 색깔 띠로 보여주기
  * 현재 달의 각각의 일자에 맞는 이벤트들을 색깔 띠로 표시함
  * 이벤트의 개수에 따라 띠의 개수가 달라지도록 xml이 아닌 동적으로 뷰를 생성함

- 불러온 이벤트가 공휴일인 경우는 빨간 색으로 표시
  * DB에서 불러온 이벤트가 우리나라 공휴일 이벤트인 경우 빨간색 색 띠로 표시함
  * 후에 좀 더 심화적인 과정으로, 공휴일 데이터들을 한 곳에 모아두는 작업을 할지 고민해봐야 할 것 같음.
## 내일할일
- 캘린더 UI 중 이벤트 관련 UI 수정
  * 이벤트들을 UI에 색 띠로 나타내는 과정 중, 여러 일자에 걸친 이벤트들이 현재 하루만 나타나고 있는데
  * 여러 일자에 걸친 이벤트일 경우에는 첫날과 끝날을 연결하여 하나의 띠로 나타낼 수 있는 방법 고민해보기

## 생각해 볼 점
- 우리나라 공휴일에 맞춰 휴일을 달력에 표시하고 일자를 빨갛게 표시하는 것이 단순할 거라고 생각을 했는데, 추석과 설날 등 매년 달라지는 공휴일도 존재하며, 구글API에서는 근 몇년간의 공휴일만을 불러오기 때문에 공휴일과 관련하여 어떻게 처리해볼지 고민할 필요가 있을 것 같다.

- 기능을 수행할수록 심화적으로 어떤 부분들을 더 수행해야 할지 보이기 시작했다.

- 지금까지 DI와 유닛테스트를 해본 경험이 없기 때문에, 설계 초기단계에서는 이 부분에 좀 더 중심을 두기로 했지만, 남은 기간동안 세부적인 기능들과 효율성관리, DI와 Test까지 모두 잡기에는 부족하다고 판단되어 어느 부분에 중심을 두고 과제를 수행할 지 고민해보았다. 

- 세부적인 기능들과 효율성을 관리하는 것에 무게를 두는것이 좀 더 과제를 수월하게 완수하는데에 도움이 될 것 같았고 또, 재미있게 과제를 수행할 수 있을 거라고 판단되었다.

# 

# 2021.08.06[DAY25]

## 오늘한일
- 각각의 월 뷰에서 그 달에 맞는 이벤트들을 불러오기
  * 각 월 프레그먼트(MonthFragment)에서 현재 달에 맞게 날짜 변환을 함
  * 현재(2021.08)를 기준으로 현재 페이지 인덱스와의 차이점을 이용하여 월 계산을 하도록 함

- 툴바(액션바)의 월 타이틀을 누르면 날짜 선택 다이얼로그를 띄워줌
  * 다이얼로그내에 달력이 존재함
  * 달력에서 날짜를 선택하여 확인 버튼을 누르면 해당 날짜로 뷰페이저 세팅
## 내일할일
- 각각의 월에 맞게 불러온 이벤트를 UI에 이쁘게 표시하기

- 월뷰의 앞부분에는 이전달 마지막 부분을, 뒷부분에는 다음달의 첫 부분을 흐리게 표시하고 각각의 월마다 주가 5개인 주, 6개인 주를 고려하여 높이를 다르게 설정하도록 하기.

## 생각해 볼 점
- 캘린더를 서버에서 불러오는 과정이나 DB에서 불러오는 과정등, 코루틴을 이용해 비동기적으로 이루어지는 과정이 많다보니 흐름을 정확히 이해하고 그 흐름에 맞춰 로직을 짜야 원하는 대로 앱이 작동한다.

- 앞으로 남은 일정동안 어느 부분들을 집중적으로 수행할지 고민해보기

# 


# 2021.08.05[DAY24]

## 오늘한일
- ViewPager에서 현재 월(뷰) 외에 다른 월 뷰들도 만들어지는 오류 해결
  * 오류를 해결하기 위해 여러 방법들을 시도해보았음.
    1. 임시 프로젝트를 만들어 해당 부분만 똑같이 구현하여 테스트를 해봄.
    2. 임시 프로젝트에서는 오류가 발생하지 않고 현재 뷰만 표시됨.
    3. 임시프로젝트에 옮긴 Fragment외에 Fragment를 포함한 Activity나 BaseActivity에서 문제점을 찾기로 함.
    4. Fragment를 담고 있는 Activity의 Layout을 변경해봄.

  * 하지만 위의 시도로는 문제를 해결하지 못했다.
  * 하지만 포기하지 않고 다음의 과정을 이어나갔다.
    1. Horizontal일 때는 오류가 발생하지 않는 것을 보고, 뷰의 높이와 관련이 있을 것이라고 생각하였다. (match_parent로 설정되어 있음)
    2. 그래서 임시로 테스트를 위해 match_parent를 500dp 로 특정 숫자를 주어 변경해보았다.
    3. 그랬더니, 오류가 발생하지 않았다.
    4. 하지만 이 방법으로는, 충분히 큰 숫자를 준다고 하더라도 어느 휴대폰 기종에나 딱 맞춰 UI를 나타낼 수는 없다.
    5. 그래서, Layout을 LinearLayout으로 변경하고, 각 뷰의 높이를 weight를 이용해 나타내었더니 뷰에도 꽉 맞게 나타나고, 오류도 발생하지 않았다.

* 구글링에서도 답을 찾을 수 없었고, StackOverflow에서도 찾을 수 없었지만, 수 많은 시도 끝에 결국 오류를 해결할 수 있었다.

## 내일할일
- 각 월뷰에 각각의 월뷰에 맞는 이벤트 UI들을 뿌려주기

- 날짜 선택 메뉴를 누르면 다이얼로그를 띄워주어 해당 선택 날짜로 뷰 이동하기

## 생각해 볼 점
- 하나의 오류 때문에 수많은 시간을 소비했지만, 직접 오류를 해결함으로써 보람을 느낄 수 있었다.

- 이 오류를 꼭 메모해두었다가, 다음에 비슷한 오류가 발생하지 않도록 주의해야겠다.

# 

## 오늘한일
- [캘린더 커스텀 뷰를 RecyclerView -> ViewPager2로 전환]
  * RecyclerView로 제작했을 때의 불편한 사항이 발생
    * 어제 리사이클러뷰를 이용해 구현한 방식은, 충분히 긴 기간의 날짜들을 모두 CalendarList에 저장을 해두었다가 RecyclerView의 아이템으로 표현하였음.
    * 즉, 1960 ~ 2040 년 까지 표현한다고 하면 이 기간안의 모든 날짜들 리스트에 저장해두었다가 표시한 방식임.
    * 하지만 이 방식으로는 월을 끊어서, 월마다 높이를 딱딱 맞춰(월 별로 주가 5개, 6개인 주가 있기 때문) 나타내기가 불편하였음. 
    * 또한, 월 선택 이동 시 position을 찾기가 다소 어려웠음
  * 이러한 불편사항을 반영하여 좀 더 구현하기 수월한 ViewPager2로 재구성을 시작함.
    * ViewPager안에 각각의 월 Fragment가 들어오게 됨
    * position은 월별로 끊어서 계산할 수 있으므로 이전의 방식보다 구현하기 효율적임.
    * 하나의 Fragment가 하나의 월을 나타낼 수 있으므로 훨씬 직관적이며, Fragment가 뷰에서 사라지는 순간 Destroy처리를 해줌으로써 메모리를 효율적으로 쓸 수 있도록 함.

## 내일할일
- ViewPager를 이용한 CustomView 구현 이어서 하기

- 구현을 하면서 좀 더 효율적인 방법 계속 생각해보기

## 생각해 볼 점
- 현재 ViewPager 방향을 Vertical로 두었을 때, 현재 보이는 페이지만이 아닌, 앞 뒤로 수많은 뷰들을 불러오는 오류가 발생함.

- 이 오류가 왜 발생했는지에 대해 고민해보고 수정하기

# 

# 2021.08.04[DAY23]

## 오늘한일
- [중간 발표를 위한 자료 구성 및 발표 연습]
  * 중간발표를 위해 그동안 설계했던 자료들과 다이어그램을 정리함
  * 정리한 자료를 바탕으로 발표ppt를 제작함
  * 다음 주 발표 전까지 변경된 사항들은 유지보수 하여 발표 예정

- [LocalDB의 스케줄들을 월 별로 불러올 수 있도록 Repository 클래스 유지보수]
  * 지금까지 구현해놓은 부분은 모든 스케줄을 한 번에 불러오고 UI에 띄우는 방식이었다면
  * 이제는 월 별로 이벤트들을 불러서 UI에 띄울 수 있도록 Dao와 Repository를 유지보수함

## 내일할일
- Custom Calendar View를 계속 구현해보면서 최대한 효율적인 기능과 방법 찾기

- 구현 이슈 정리

## 생각해 볼 점
- 달력과 스케줄을 나타내는 커스텀 UI가 이 앱의 핵심인 만큼 너무 성급하게 구현하지 말고 최대한 효율적이고 좋은 방법을 찾아 고민해보기

- 구현시 발생한 오류들을 메모해두었다가 다음에 비슷한 오류가 발생하지 않도록 주의하기

# 

# 2021.08.03[DAY22]

## 오늘한일
- [캘린더 커스텀뷰 UI 구현 시작]
  * 위아래로 스크롤하여 무한히 달력을 넘길 수 있는 뷰를 만들기 위해 RecyclerView와 Adapter 학습 및 적용
  * 이번 달의 달력과 지난, 다음 달의 날짜를 어떻게 계산하여 나타낼 건지에 대한 알고리즘 작성

- 중간 발표를 위한 발표 자료 준비
  * 중간 발표 날짜가 공지되어, 조금씩 발표준비를 위해 틈틈이 구현과 함께 자료 준비를 하고 있음

## 내일할일
- 멘토님과 함께 중간 발표 예비 연습

- 커스텀뷰 작성 및 보완

## 생각해 볼 점
- 실제 웍스앱의 캘린더 처럼 나타내기 위해 데이터를 어떻게 가공해서 뷰에 넣어야 할지 고민해보기

- 무한 스크롤을 부드럽게 최적화하여 나타내기 위한 방법 고민해보기

# 

# 2021.08.02[DAY21]

## 오늘한일
- [Dagger 복습 및 설계 시작]
  * DI 적용을 위해 지금까지 학습한 Dagger 내용 복습
  * 현재의 프로젝트에 적용하기 위한 코드 작성 시작

- 현재까지의 플로우를 시퀀스 다이어그램으로 정리
  * 노트에 먼저 시퀀스 다이어그램 작성
  * UML 툴을 이용해 깔끔하게 옮겨서 정리 예정

## 내일할일
- 커스텀뷰 캘린더UI 구현 시작

- RecyclerView를 이용해 월 뷰 무한스크롤 작성

## 생각해 볼 점
- DI를 작성하면서 깔끔한 코드와 테스트 가능한 코드를 만들기 위해 코드를 수정할 필요를 느꼈습니다.

- 캘린더 커스텀뷰를 만들기 위해 참고하면 좋을 예시들을 찾아서 따라해보면 좋을 것 같습니다.

# 

# 2021.07.30[DAY20]

## 오늘한일
- [책임, 역할, 협력을 이용한 객체지향 설계](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY19%5D%20책임,%20역할,%20협력을%20이용한%20객체지향%20설계.md)
  * 객체지향 설계를 하는데에 있어서 굉장히 중요한 개념을 예시를 통해 설명한 블로그를 참조하여 공부함
  * 이 과정을 통해 현재 프로젝트에서 설계해놓은 부분들을 재점검하며 수정함

- [LocalDB이슈 해결 및 커스텀뷰 구현 준비]

## 내일할일
- 본격적으로 캘린더 커스텀뷰를 구현할 예정입니다.

- 커스텀뷰를 구현하면서 틈틈이 DI를 같이 적용할 수 있도록 꾸준히 공부할 예정입니다.

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 중간중간 설계적인 부분을 수정해야 할 때, 책임과 역할 협력을 이용한 객체지향 설계를 할 수 있도록 신경써야 할 필요가 있다고 느꼈습니다.

- 캘린더 커스텀뷰를 구현하기 전, 여러 블로그들을 찾아보며 좋은 예시 참고하기.

# 

# 2021.07.29[DAY19]

## 오늘한일
- [RoomDB의 TypeConverter 오류 해결](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/이슈정리.md)
  * LocalDB 생성시, 기본 타입이 아닌 데이터들에 대해 파싱 오류가 발생하였는데 이를 TypeConverter를 이용하여 오류를 해결
  * API의 JSON 응답 형태를 보고, 이에 맞게 데이터들을 구성하여 데이터베이스를 작성

- [Navigation Drawer의 구현] -> 오른쪽 이미지
  * 불러온 캘린더List를 네비게이션 드로어에서 보여주고, 이를 선택하여 선택한 캘린더만 뷰에 나타날 수 있도록 하기위해 먼저, 프레그먼트와 네비게이션 드로어를 구현하였다.

<img src = "https://user-images.githubusercontent.com/46186664/127775028-a30f57d7-6f0d-46b6-95e6-46a3037d4f5b.png" height = "300" align="right">

## 내일할일
- 이번주 까지의 목표를 'DB 구성'으로 잡았기 때문에 DB와 관련해 그동안 모아놓은 이슈들을 집중적으로 모두 해결.

- 책임, 역할, 협력을 이용한 객체지향 설계 개념 공부 및 정리

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 구현을 진행할수록 객체지향적인 프로그래밍의 중요성과 이러한 프로그래밍을 위한 개념정립이 좀 더 필요함을 깨달았습니다.

- 객체지향 프로그래밍의 개념이 좀 더 확실해질 수 있도록 틈틈이 공부할 예정입니다.

- 주말동안 DI 개념공부를 진행하며 다음주부터 커스텀 캘린더 뷰 UI 작업을 진행하며 DI를 구현할 수 있도록 할 예정입니다. 

# 


# 2021.07.28[DAY18]

## 오늘한일
- [MVVM패턴으로 LocalDB와 ViewModel 리팩토링](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY18%5D%20MVVM%20패턴으로%20리팩토링(Repository).md)
  * Activity에 작성했던 Activity <-> LocalDB와의 참조작업이 ViewModel <-> LocalDB에서 일어날 수 있도록 코드를 리팩토링 하였습니다.
  * DataSource 인터페이스와 이를 구현한 Repository를 구현함으로써 서버API와의 작업이나 로컬DB와의 작업은 Repository를 통해 일어나도록 코드를 구성함으로써
  * Repository에 다른 Repository가 오더라도 테스트가 될 수 있도록 구조를 리팩토링 하였습니다.

## 내일할일
- LocalDB 관련 TypeConverter 오류와 Entity 오류를 수정하여 API의 모든 항목을 가져올 수 있도록 수정

- 불러온 캘린더List를 네비게이션 드로어에서 보여주고, 선택할 수 있도록 구현

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 구현을 진행하면서 중간중간 이슈가 발생하면 설계했던 것 처럼 완벽히 구현을 하기가 다소 어려운 점이 있었다.

- 그래도 최대한 마일스톤 설계 했던 것을 따라갈 수 있도록 정한 기간안에 해당 구현을 꼭 끝낼 수 있도록 시간을 좀 더 투자해야겠다.

- 주말에 시간을 활용하여 설계 다이어그램을 좀 더 보완하여 흐름을 완벽히 파악할 수 있도록 해야겠다.

# 


# 2021.07.27[DAY17]

## 오늘한일
- [API 호출 및 싱글톤 객체 생성](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/ApiService객체%20관리.md)
  * MVVM 아키텍처를 적용하기 전에 짰던 서비스 객체를 MVVM 패턴을 적용하여 리팩토링
  * (서비스 객체는 Google Calendar API를 호출할 때 반드시 필요한 객체인데 이를 싱글톤으로 구성하여 처음 한번만 생성을 하고 계속 받아서 쓰는 식으로 구현함)
  * 서비스 객체를 생성할 때 context 관련 요소가 필요했는데 ViewModel에서는 context 사용을 지양해야 해서 이와 관련된 부분을 고민하고 해결함

## 내일할일
- API 호출을 통해 받아온 데이터를 LocalDB에 저장. 및 MVVM패턴을 적용한 API 호출 관련 함수 리팩토링

- LocalDB를 ViewModel에서 실행할 수 있도록 MVVM 패턴으로 리팩토링

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 기존에 MVVM아키텍쳐를 적용하지 않고 Activity나 Fragment에서 구현했던 부분을 리팩토링 하는 과정에서 주로 이슈가 발생.

- 이슈를 해결하면서 기능적인 부분보다 안드로이드 기본 개념(context, singleton, 객체지향 등)이 많이 중요하다는 것을 깨달음.

- 짜투리 시간들을 활용하여 객체지향과 안드로이드에 대한 기본 개념들에 대한 문서들을 꾸준히 읽으면서 개념을 확립해나가야 할 것 같습니다.

# 


# 2021.07.26[DAY16]

## 오늘한일
- [Google Calendar API 분석](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY16%5D%20Google%20Calender%20API%20분석.md)
  * Google Calendar API 의 전체 메소드와 파라미터, Response에 대해 분석
  * 프로젝트에서 사용하게 될 CalendarList, Calendars, Events, Colors 집중 분석하여 문서로 정리
  * 이를 바탕으로 LocalDB 구현 시작

## 내일할일
- 분석한 내용을 바탕으로 LocalDB 구현 시작하기

- LocalDB 구현을 진행하면서 LocalDB를 사용하게 될 함수 함께 작성

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- API에 대한 전체적인 분석 없이 LocalDB를 먼저 구현을 하려고 하다보니 꼬이기 시작하면서 순서가 잘못되었음을 깨달았습니다.

- 다소 시간이 걸리더라도 API에 대한 분석을 확실하게 한 후에 LocalDB 구현이 이루어져야 함을 알게 되었습니다.

- 오늘 분석한 내용들을 바탕으로 내일 다시 LocalDB 구현을 시작하려고 합니다.

# 

# 2021.07.23[DAY15]

## 오늘한일
- [마일스톤 작성 마무리](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY15%5D마일스톤.md)
  * 앱의 전체기능, 아키텍쳐, Local DB 구현으로 나눠 마일스톤을 정리하였습니다.
  
- [Entity작성 관련 이슈발생 및 보완](https://oss.navercorp.com/ghdwns315/ArchitecturePractice/commit/c32a9fa9281a35348eaba05f44cd4d5f136f9fe4)
  * CalendarListEntry를 RoomDB에 그대로 저장하려고 했지만 Converter가 필수로 필요한 상황이 발생.
  * CalendarListEntry는 직접 만든 클래스가 아닌, 구글 라이브러리에서 제공해주는 데이터 형식으로 룸에 바로 저장이 안됨
  * 그래서 CalendarListEntity 클래스를 직접 생성 후 이를 룸DB에 저장하는 방향으로 전환.
  
- [Service객체 관련 이슈발생 및 보완](https://oss.navercorp.com/ghdwns315/ArchitecturePractice/commit/c32a9fa9281a35348eaba05f44cd4d5f136f9fe4)
  * API를 호출하는데 필수로 필요한 Service객체를 메인에서 한번 생성 후 Preference or IntentExtra로 관리하려고 하였음.
  * Service객체는 구글 라이브러리에서 제공하는 Parcebel하지 않은 객체로, IntentExtra로 넘겨주거나 PreferenceManager로 관리하지 못하는 상황이 발생
  * 싱글톤으로 한 번 빌드를 한 후에 호출하여 사용하는 방향으로 전환.

## 내일할일
- Google Calendar API의 전체 메소드와 파라미터, Response 분석

- 분석한 내용을 통해 LocalDB를 구현할 수 있도록 내용 정리 및 작성해보기

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- RoomDB의 편의성을 우선순위로 생각하여 DB설계를 하다보니 DB에 서비스 객체와 CalendarListEntry를 그대로 저장하려고 했던 실수가 발생한 것 같습니다.

- RoomDB의 편의성보다는, 먼저 DB설계를 우선으로 생각하여 설계를 한 후에 이 DB를 구현하는데에 있어 Room의 이점을 이용하는 방향으로 전환하려고 합니다.

- LocalDB의 설계하기 위해서는 구글 캘린더 API 문서를 꼼꼼히 분석해야 할 것 같습니다.

# 

# 2021.07.22[DAY14]

## 오늘한일
- [데이터 로직 중 로그인 및 API연결 부분에 MVVM패턴 적용하기](https://oss.navercorp.com/ghdwns315/ArchitecturePractice/tree/master/app/src/main/java/com/example/architecturepractice)
  * 데이터 로직과 UI 부분을 분리하여 구현함으로써 나중에 어떤 캘린더UI가 오더라도 떼어서 갖다 붙일 수 있는 구조를 갖기 위해서
  * 먼저 기능구현을 캘린더UI의 이전까지 완료한 후 일단 구현한 부분까지만 MVVM과 Dagger를 적용하려고 합니다.
  * 그래서 캘린더UI를 구현하기에 앞서 데이터 로직부분 까지를 먼저 기술셋을 적용하는 계획으로 변경하였습니다.
  
- 마일스톤 보완
  * MVVM패턴과 Dagger, Unit/UI Test에 대한 경험이 없다보니 이 부분에 대한 마일스톤 계획에 대한 감이 잡히지 않았습니다.
  * MVVM패턴을 조금씩 적용해보면서 감을 잡기 시작했고, 이 부분에 대한 마일스톤을 작성하였습니다.

- 캘린더 리스트 중 하나의 캘린더를 정해 모든 스케줄 목록을 불러와 TextView에 띄워보기
  * 연결한 캘린더API를 통해 스케줄들을 불러와 TextView에 확인하는 작업을 하였습니다.
  * 이렇게 데이터만 잘 준비되어 있으면 UI가 준비되었을 때 뿌려주기만 하면 되기 때문에
  * 데이터 로직 부분 먼저 기술셋을 적용하기로 하였습니다.

## 내일할일
- 이어서 캘린더 목록 선택과 스케줄에도 MVVM패턴 적용하기

- MVVM패턴을 적용하면서 Dagger 적용을 위한 구조 생각해보기

- 마일스톤 작성 마무리하기

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 패턴 적용없이 액티비티에 기능 구현을 할 때는 패턴과 DI에 대한 감이 잡히지 않았었는데 확실히 MVVM패턴 적용을 시작하다 보니 어느 부분에 의존성 주입이 필요한지 보이기 시작했고 Dagger의 필요성이 보이기 시작했습니다.

- 이를 바탕으로 MVVM 코드를 짜면서 Dagger가 필요한 부분들에 대해 표시를 해 두어 Dagger 적용을 좀 더 수월하게 하려고 합니다.

# 

# 2021.07.21[DAY13]

## [오늘한일](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY13%5D%20Google%20Calendar%20API%20접근%20및%20이슈.md)
- [연동된 구글 계정으로 구글 캘린더 API를 이용해 캘린더 가져오기](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY13%5D%20Google%20Calendar%20API%20접근%20및%20이슈.md)
  * 로그인 된 구글 계정에 등록된 캘린더 리스트들을 가져오는 기능을 구현하였다.
  * 구현 과정 중 두 가지 이슈가 발생(접근권한, 데드락)하였고 모두 해결하였다.
  
- 마일스톤 보완
  * FeatureList를 바탕으로 마일스톤 작성을 시작하였으며 기능 구현을 진행하면서 보완해나가고 있다.
  * 이번주 내로 마일스톤을 완성하여 구체적인 개발계획을 세울 예정이다.

- 인적성 검사
  * 14:00 ~ 18:00 진행

## 내일할일
- 연동한 구글 캘린더 리스트 중 선택한 리스트의 스케줄 모두 받아오기

- 구현된 기능개발 코드에 아키텍쳐 및 Dagger 적용해보기

- 금요일에 마일스톤 md산정을 마무리 할 수 있도록 마일스톤 작성 및 보완 정리하기

- 기능 개발을 진행하며 발생한 이슈들 정리하기

## 생각해 볼 점
- 현재, 구글 캘린더 API에서 oAuth2.0을 이용해 권한을 요청하고 있는데 테스트 계정에 등록된 계정 외에는 권한 요청이 안되고 있다. => 테스트 단계에서 등록된 계정 외에도 권한요청이 가능한지 확인하기

- 구현해놓은 기능 코드를 바탕으로 아키텍쳐 설계를 어떻게 진행하면 좋을지 생각해보기

# 


# 2021.07.20[DAY12]

## [오늘한일](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY12%5D%20Google%20API%20연동.md)
- [구글 로그인 API 연동](https://oss.navercorp.com/ghdwns315/AndroidStudy/blob/master/StudyLog/%5BDAY12%5D%20Google%20API%20연동.md)
  * 안드로이드의 내장된 SDK를 이용해 구글 로그인을 구현하는 것과 파이어베이스를 이용해 구글 로그인을 구현하는 방법을 알아보았다.
  * 파이어베이스를 이용한 방법은 이전에 구현해본 경험이 있기 때문에
  * 안드로이드의 SDK를 이용해 구현해보았다.
  
- 구글 캘린더 API 프로젝트 생성
  * 구글 클라우드 플랫폼에 프로젝트를 생성하여 OAuth 2.0 클라이언트 ID를 생성하였다.
  * 이 셋팅을 바탕으로 내일 로그인된 구글 계정의 스케줄을 받아오는 기능을 구현해 볼 예정이다.

## 내일할일
- 구글 로그인된 계정으로 구글 캘린더의 스케줄 받아오기

- FeatureList를 바탕으로 개발자의 관점에서 마일스톤 작성하기

- 계속해서 기능 구현 해보기 ( 아키텍쳐 적용 전 실습 )

## 생각해 볼 점
- FeatureList는 사용자의 입장에서 앱의 기능을 생각하여 작성을 했다면, 마일스톤은 개발자의 관점에서 이를 재구성해서 작성해봐야 할 것 같다.

- 마일스톤 작성과 함께 기능 구현을 꾸준히 계속 진행하면서 프로젝트를 발전시켜 나가려고 한다.

# 


# 2021.07.19[DAY11]

## 오늘한일
- [Feature List 작성](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY11%5D%20Feature%20List.md)
  * 여러 스케줄 앱들을 비교하면서 기능 파악
  * 이를 바탕으로 앱의 전체적인 기능과 흐름 작성
  
- [아키텍쳐 적용 전의 레포지토리 생성](https://oss.navercorp.com/ghdwns315/BeforeArchitecture)
  * 아키텍처를 적용하기 전 기능 구현을 위한 레포지토리 생성
  * 앞으로 여기서 아키텍처 적용 전의 기능 구현 및 테스트를 진행할 예정

## 내일할일
- 구글 API를 바탕으로 간단한 기능을 직접 구현해보기

- 시간이 날 때 마다 아키텍처 구성을 생각해보기

- 프로젝트 기간을 생각하여 계획 세워보기

## 생각해 볼 점
- 아키텍처 적용 전의 코드들을 아키텍처에 어떻게 적용할지 생각해보기

- 가장 어려워 하는 부분과 해당 부분을 고려하여 프로젝트 기간을 나눠 계획 세워보기

# 


# 2021.07.16[DAY10]

## 오늘한일
- [Dagger의 필수 개념](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Dagger%20Example.md)
  * Inject, Component, Subcomponent, Module, Scope
  * Dagger의 전체적인 흐름 파악
  * [예제를 통해 실제 Dagger 사용해보기](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Dagger%20Example2.md)
  
- [Dagger Qualifier, BindsInstance](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Dagger(Qualifier%2C%20Named%2C%20BinsInstance).md)
  * Qualifier
  * Named
  * BindsInstance를 사용한 예시 작성하기

- [Dagger의 Injection](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Dagger%20(Provider%20Injection%2C%20Lazy%20Injection).md)
  * Provider Injection
  * Lazy Injection

- [Dagger의 Scope](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Dagger%20(Scope%2C%20Singleton).md)
  * Scope
  * Singleton
  * SubComponent

- [Dagger의 Multibinding](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY10%5D%20Multibinding%20%40IntoSet%20%40IntoMap.md)
  * @IntoSet
  * @IntoMap


## 내일할일
- 프로젝트 설계 시작

- 여러 캘린더 앱들을 실행해보면서 사용자 입장에서의 기능 흐름을 파악하여 구성을 그려보기

- MVVM 기반으로 패키지 구성 생각해보기

## 생각해 볼 점
- 프로젝트 설계를 진행하기 전에 기능들이 어떠한 흐름으로 구현될 것인지를 그려봐야 할 것 같습니다.

- 한 가지 기능을 예로 들어 이 기능을 위해선 어떠한 구조와 파일들이 필요한 지 그려보려고 합니다.

- 새로 배운 기술셋들에 친숙해질 수 있도록 설계를 진행하면서도 꾸준히 복습을 하려고 합니다.

# 


# 2021.07.15[DAY09]

## 오늘한일
- [DI(의존성 주입)](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY09%5D%20DI(의존성%20주입).md)
  * 의존성 주입의 개념과 사용하는 이유에 대해 알아보기
  * 수동 의존성 주입 개념공부를 통해 Dagger에 대한 바탕지식 쌓기
  
- [Dagger](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY09%5D%20Dagger.md)
  * Dagger의 팩토리 생성
  * Dagger Component
  * Scope 에 대한 개념과 안드로이드 공식 문서 참고하여 정리

- [Dagger의 기본 개념](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY09%5D%20Dagger%20기본개념.md)
  * Inject
  * Component
  * Subcomponent
  * Module
  * Scope 에 대한 개념과 예제 코드 작성하기

## 내일할일
- Dagger 관련 블로그와 문서 참조하여 이해될 때 까지 반복 숙지하기

- 멘토님이 추천해주신 Dagger관련 서적 읽으면서 개념 정리

- 네이버 캘린더 앱과 실제 캘린더 관련 앱들을 사용해보면서 설계를 그려보기

## 생각해 볼 점
- Dagger에 대한 개념이 많이 어렵다 보니 반복해서 공부해야 할 것 같습니다.

- 다음주에 프로젝트 설계를 최대한 빨리 시작할 수 있도록 더 시간을 내어 공부하려고 합니다.

- 앞으로 자기전에 오늘 구입한 Dagger 서적을 읽으면서 최대한 빨리 Dagger에 친숙해 지도록 하려고 합니다.

# 

# 2021.07.14[DAY08]

## 오늘한일
- [MVP 샘플 코드 데이터 패키지 분석](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY08%5D%20MVP샘플코드의%20Data패키지.md)
  * 데이터 패키지 각각의 클래스와 인터페이스 분석하기
  * SOLID 원칙과 연결하여 분석하기
  * 누군가에게 설명하듯이 분석하여 기술하기
  
- [MultiThreading](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY08%5D%20MultiThreading.md)
  * MultiThreading
  * Executor
  * ThreadPool

- [Looper와 Handler](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY08%5D%20Looper%2C%20Handler%2C%20HandlerThread.md)
  * Main Thread
  * Looper
  * Handler
  * Message & Message Queue

## 내일할일
- MVVM 샘플 코드를 SOLID 원칙과 비교하며 분석하기

- 틈날 때 마다 Dagger와 관련된 문서, 블로그 읽기

- 시퀀스 다이어그램 관련 내용 공부하기

## 생각해 볼 점
- 오늘 MVP 패턴의 데이터패키지를 분석해보면서 SOLID 원칙을 지키면서 개발을 하는 이유에 대해 알게 되었습니다.

- 내일 MVVM 코드를 분석할 때, 이 점을 유의하여 분석을 하려고 합니다.

- 앞의 패턴을 파악하느라 시간을 많이 소비한 만큼, Dagger에 빠르게 적응하기 위해 틈날 때 마다 Dagger와 관련된 문서들을 읽으려고 합니다.

# 

# 2021.07.13[DAY07]

## 오늘한일
- [MVP 패턴 구글 아키텍쳐 샘플 코드 분석 ](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY07%5D%20MVP%20구글%20샘플%20코드%20분석하기.md)
  * MVP 패턴에서 사용자 이벤트 하나가 발생했을 때 작동 과정 설명하기
  * 샘플 코드의 Task 내의 Activity, Fragment, Presenter, Contract 각각의 역할과 코드 분석하기
  * DataSource에서는 함수명만 명시하고 Repository에서 다시 구현을 하는 이유
  
- [ViewModel과 코루틴](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY07%5D%20ViewModel(advanced).md)
  * ViewModel을 이용해 숫자 카운트 앱을 만들어 보면서 이해하기
  * ViewModel의 SavedStateHandle
  * ViewModelScope


## 내일할일
- MVP 샘플 코드의 Data패키지(local, remote) 코드 분석 및 활용해보기

- Android Looper, Handler, Main, Ui Thread 개념 학습하기

## 생각해 볼 점
- MVP 패턴에 대해 확실히 알고가야 MVVM을 정확히 이해하고 활용할 수 있을 것 같습니다. 남은 Data패키지에 대해서도 분석한 후에 그동안 이해한 MVP를 바탕으로 MVVM을 활용하려고 합니다.

- 코루틴을 잘 활용하기 위해서는 안드로이드의 Looper, Handler, Thread의 개념을 확실하게 짚고 넘어가야 할 것 같습니다. 샘플 코드의 Data패키지에서도 Looper와 Handler, Thread의 개념이 등장하기 때문에 학습을 한 후에 코드를 다시 보려고 합니다.

# 

# 2021.07.12[DAY06]

## 오늘한일
- [MVP 패턴](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY06%5D%20MVP패턴.md)
  * MVP 패턴이란?
  * MVP 패턴이 등장하게 된 이유
  * MVP 패턴의 장단점
  * MVP 패턴의 구조
  * 안드로이드 공식 설계 코드와 함께 보는 MVP 패턴 코드
- [MVVM 패턴](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY06%5D%20MVVM패턴.md)
  * MVVM 패턴이란?
  * MVVM 패턴이 등장하게 된 이유
  * MVVM 패턴의 장단점


## 내일할일
- ViewModel을 이용해 실습 진행해보기

- 안드로이드 MVVM 공식 설계 코드를 뜯어보며 MVVM 패턴 구조 파악하기

- DataBinding에 대한 개념 공부하기

## 생각해 볼 점
- 각각의 패턴에 대한 개념을 이론적으로 달달 외우려하기 보다는 직접 실습을 통해 체감을 해보며 습득을 하면 좋을 것 같다는 생각을 했습니다.

- 너무 조바심을 갖기보다 직접 하나씩 코드를 통해 구현을 해보면서 하나씩 발전해 나가면 좋을 것 같다고 생각합니다.

- 기간이 정해진 프로젝트인 만큼 모르는 부분이 발생하면 혼자서 계속 고민만하다가 잘못된 방향으로 빠지기보다, 멘토님의 도움을 받아 방향을 잡는것이 좋겠다는 생각을 했습니다.

# 

# 2021.07.09[DAY05]

## [오늘한일](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY05%5D%20Coroutine.md)
- [Coroutine(코루틴)](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY05%5D%20Coroutine.md)에 대해 학습해보았습니다.
  * Coroutine vs Thread를 통해 Coroutine을 사용하는 이유에 대해 알아보았습니다.
  * Coroutine Dispatcher
  * Coroutine Context
  * Coroutine Scope
  * Coroutine Builder + Job에 대해 공부해 보았습니다.
  * suspend(일시 중단 함수)
  * 위의 항목들로 Coroutine 직접 사용해보기



## 내일할일
- ViewModel과 MVVM 패턴의 구조 파악하기

- LiveData에 대해 학습하기

- MVVM에 대해 어느정도 숙달이 되었다면 기존 코드를 수정해보기

## 생각해 볼 점
- 코루틴에 대해서 이번에 처음 공부를 하게 되었는데, 시작하기 전에는 처음이다 보니 두려움이 있었지만 막상 공부를 해보니 금방 따라갈 수 있었습니다.

- 남은 기술셋에 대해서도 빠르게 습득할 수 있도록 집중하여 학습할 예정입니다.

- MVVM에 대한 개념학습이 완료되면, 실전에서 쓸 수 있도록 직접 간단한 앱제작을 통해 실습을 하며 익히려고 합니다.

# 


# 2021.07.08[DAY04]

## [오늘한일](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY04%5D%20ViewModel%2C%20ListAdapter%2BDiffUtil.md)
- MVVM 패턴의 핵심이라고 할 수 있는 ViewModel에 대해 학습해보았습니다.
  * ViewModel의 개념
  * ViewModel과 생명주기
  * ViewModel의 사용목적
  * 예제코드를 통한 ViewModel의 실습

- 어제 학습한 RecyclerView + ListAdapter + diffUtil 을 직접 활용해보았습니다.
  * RecyclerViewAdapter대신 ListAdapter와 diffUtil을 이용해 RecyclerView를 구성
  * RecyclerViewAdapter대신 ListAdapter와 diffUtil을 사용하는 이유

- MVVM, 코루틴 관련 블로그들을 찾아보며 개념 학습을 함


## 내일할일
- ViewModel과 MVVM패턴에 익숙해지도록 지속적으로 개념공부와 실습 병행하기

- 코루틴에 대해 공부한 후 직접 실습해보기

- Dagger의 개념에 대해 공부해보기

## 생각해 볼 점
- 멘토님과의 면담 후 지금 당장은 앱을 그려보기보단 기술셋의 개념에 대해 공부하는 방향으로 정했습니다.

- 사용할 기술셋들(MVVM, 코루틴, Unit/Ui Test) 에 대해 아직 많이 서툰만큼 속도를 내어 공부하려고 합니다.

- 먼저 코루틴에 대해 확실히 개념을 잡고 직접 실습을 해 볼 예정입니다.

# 


# 2021.07.07[DAY03]

## [오늘한일](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY03%5D%20ViewBinding%2C%20Local%20DB.md)
- [ViewBinding을 공부하여 안드로이드 앱에 적용시켜 봄]
  * DataBinding을 학습하기 전 보다 구현이 간편한 ViewBinding을 먼저 공부해봄
  * 기존의 메인액티비티도 setContentView(R.layout.activity.main) 대신 setContentView(binding.root)를 적용
  <img src = "https://media.oss.navercorp.com/user/25503/files/dc924400-df6b-11eb-91b3-2c5e94b17c1e" align="right">

- 인턴 프로젝트의 로컬DB 사용을 위해 안드로이드 Room을 이용한 로컬DB 공부를 함
  * 어제 만든 인터파크 도서 api 데이터를 이용한 앱에 로컬DB를 추가하여 앱을 보완시킴
  * 앱의 책 관련 데이터는 api를 통해 받아오지만, 책 제목 검색기록이나 리뷰는 로컬DB를 활용함


- AAC, MVVM 패턴 관련 블로그들을 찾아보며 개념 학습을 함


## 내일할일
- 코틀린을 이용한 Fragment 활용해보기

- RecyclerView와 ListAdapter + diffUtil 활용하여 인턴 프로젝트의 캘린더 스크롤 관련 연습

- MVVM 패턴 개념 이어서 학습하기

## 생각해 볼 점
- 웍스 캘린더처럼 무한으로 아래 위로 스크롤을 하기 위해 필요한 부분들에 대해 학습해야 할 것 같습니다.

- RecyclerView의 스크롤에 대해 공부하던 중 ListAdapter와 DiffUtil에 대해 알게되었습니다. 

- 기존의 데이터 리스트와 교체할 데이터 리스트를 비교해서 실질적으로 교체가 필요한 부분만을 업데이트 하기 때문에 기존의 RecyclerView Adapter보다 효율적이라는 것을 알게 되었습니다.

- 이를 이용해 RecyclerView를 구성해봐야 겠다는 생각을 했습니다.

# 

# 2021.07.06[DAY02]

## 오늘한일
- [코틀린을 이용해 Retrofit을 사용하기](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/blob/master/StudyLog/%5BDAY02%5D%20Retrofit%20(With%20Kotlin).md)
  * 구글 캘린더 API 연동 연습을 위해 Retrofit 공부
  * 인터파크 도서 api를 받아와서 안드로이드 뷰에 그려봄
  * 자바로 Retrofit을 사용했던 과거 프로젝트 코드와 비교하며 공부해봄
  <img src = "https://media.oss.navercorp.com/user/25503/files/c60bce80-df12-11eb-8cbf-c7d7d6553cc8" align="right">

- 업무기기 작업 환경 설정(소스트리, 깃헙데스크탑을 설치 및 git 연동)

- 안드로이드(With Kotlin) 강의 중 Retrofit 관련 강의를 수강


## 내일할일
- MVVM에 입문하기 전, ViewBinding과 DataBinding에 대해 공부하기

- 어제 연동했던 인터파크 도서 api, Retrofit과 
  오늘 공부한 DataBinding을 이용해 도서 검색 앱 제작해보기

## 생각해 볼 점
- MVVM을 공부하기 전 필수로 알아야 할 데이터바인딩, 뷰모델 등에 대해 먼저 공부를 하려고 합니다.

- MVVM 패턴으로 앱을 구현해본 경험이 없기 때문에 본 프로젝트 시작 전에 최대한 MVVM 패턴에 대한 지식을 습득해야 할 것 같습니다.

- 오늘 공부한 내용은 내일 누구에게나 자연스럽게 설명할 수 있을 정도로 반복해서 공부하려고 합니다.

# 
# 2021.07.05[DAY01]

## 오늘한일
- OT 참여 및 필수 영상 시청
- [Kotlin 기본 문법 공부 및 정리](https://oss.navercorp.com/ghdwns315/AndroidGoogleCalendar/wiki/DAY01-(코틀린-기초-문법))
ScopeFunction(apply, let, also, with, run), ?(nullable),  lambda등

- MAC 안드로이드 스튜디오 설치 및 세팅


## 내일할일
- 코틀린을 이용해 기존 자바 프로젝트 리팩토링 하면서 코틀린에 친숙해지기

- 코틀린을 이용해 RestAPI 연계 해보기

- 코틀린 안드로이드 강의 수강하기

## 생각해 볼 점
- 인턴 프로젝트는 자바가 아닌 **코틀린**으로 진행되다 보니 좀 더 코틀린에 익숙해지기 위해 꾸준히 공부를 하며 적용시키는 연습을 해야 할 것 같습니다.

- 최대한 빠르게 코틀린에 익숙해진 후에 AAC, MVVM등 프로젝트에 필요한 부분들을 학습하려고 합니다.

- 공부한 내용들을 위키에 문서로 정리하여 학습 효율을 높이려고 합니다.